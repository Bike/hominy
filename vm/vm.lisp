(in-package #:burke/vm)

(defstruct (frame (:constructor %make-frame (registers stack)))
  (registers (error "missing arg") :type simple-vector :read-only t)
  (stack (error "missing arg") :type simple-vector :read-only t)
  (sp 0 :type (and fixnum unsigned-byte)))

(defun make-frame (regsize stacksize)
  (%make-frame (make-array regsize) (make-array stacksize)))

(defun spush (object frame)
  (setf (aref (frame-stack frame) (frame-sp frame)) object)
  (incf (frame-sp frame)))
(defun spop (frame) (aref (frame-stack frame) (decf (frame-sp frame))))
;; Get the last N pushes as a list.
(defun gather (n frame)
  (loop repeat n
        for i from (- (frame-sp frame) n)
        collect (aref (frame-stack frame) i)
        finally (decf (frame-sp frame) n)))

(defun reg (frame i) (aref (frame-registers frame) i))
(defun (setf reg) (object frame i) (setf (aref (frame-registers frame) i) object))

(defclass module ()
  ((%bytecode :initarg :bytecode :reader bytecode
              :type (simple-array (unsigned-byte 8) (*)))
   (%constants :initarg :constants :reader constants :type simple-vector)))

(defclass code (i:operative)
  ((%module :initarg :module :reader module :type module)
   (%xep :initarg :xep :reader xep :type (and unsigned-byte fixnum))
   (%sep :initarg :sep :reader sep :type (and unsigned-byte fixnum))
   (%nregs :initarg :nregs :reader nregs :type (and unsigned-byte fixnum))
   (%nstack :initarg :nstack :reader nstack :type (and unsigned-byte fixnum))
   (%nclosed :initarg :nclosed :reader nclosed :type (and unsigned-byte fixnum))))

(defclass closure (i:operative)
  ((%code :initarg :code :reader code)
   (%closed :initarg :closed :reader closed :type simple-vector)))

(defun enclose (code closed)
  (make-instance 'closure :code code :closed (coerce closed 'simple-vector)))

(defun vm (bytecode frame closure constants &key (ip 0))
  (declare (optimize debug)
           (type (simple-array (unsigned-byte 8) (*)) bytecode)
           (type frame frame)
           (type simple-vector closure constants)
           (type (and unsigned-byte fixnum) ip))
  (flet ((code () (aref bytecode ip))
         (next-code () (aref bytecode (incf ip)))
         (next-label () (aref bytecode (incf ip))) ; TODO: Longer labels
         (reg (i) (reg frame i))
         ((setf reg) (object i) (setf (reg frame i) object))
         (closure (i) (aref closure i))
         (constant (i) (aref constants i))
         (spush (object) (spush object frame))
         (spop () (spop frame))
         (gather (n) (gather n frame)))
    (loop
      (ecase (code)
        ((#.o:nop) (incf ip))
        ((#.o:drop) (spop) (incf ip))
        ((#.o:ref) (spush (reg (next-code))) (incf ip))
        ((#.o:set) (setf (reg (next-code)) (spop)) (incf ip))
        ((#.o:closure) (spush (closure (next-code))) (incf ip))
        ((#.o:const) (spush (constant (next-code))) (incf ip))
        ((#.o:cons) (let ((cdr (spop))) (spush (cons (spop) cdr))) (incf ip))
        ((#.o:list) (gather (next-code)) (incf ip))
        ((#.o:car) (spush (car (the cons (spop)))) (incf ip))
        ((#.o:cdr) (spush (cdr (the cons (spop)))) (incf ip))
        ((#.o:return) (return-from vm (spop)))
        ((#.o:jump) (incf ip (next-label)))
        ((#.o:jump-if-true)
         (let ((label (next-label)))
           (if (eql (spop) i:true)
               (incf ip label)
               (incf ip))))
        ((#.o:combine)
         (let ((env (spop)) (combinand (spop)) (combiner (spop)))
           (spush (i:combine combiner combinand env)))
         (incf ip))
        ((#.o:tail-combine)
         ;; this isn't much of a tail combination - the lisp may not be smart enough
         ;; to axe VM's stack frame before combining. FIXME
         (let ((env (spop)) (combinand (spop)) (combiner (spop)))
           (return-from vm (i:combine combiner combinand env))))
        ((#.o:lookup)
         (let ((env (spop)) (sym (spop))) (spush (i:lookup sym env)))
         (incf ip))
        ((#.o:enclose)
         (let ((code (constant (next-code))))
           (spush (enclose code (gather (nclosed code)))))
         (incf ip))
        ((#.o:make-environment)
         (let ((names (constant (next-code))))
           (spush (i:make-fixed-environment names (gather (length names)) (spop))))
         (incf ip))
        ;; call, tail-call
        ((#.o:err-if-not-cons)
         (let ((object (spop)))
           (unless (consp object) (error 'type-error :datum object :expected-type 'cons)))
         (incf ip))
        ((#.o:err-if-not-null)
         (let ((object (spop)))
           (unless (null object) (error 'type-error :datum object :expected-type 'null)))
         (incf ip))))))

;;; CODEs can be used directly as combiners iff they are not closures.
(defmethod i:combine ((combiner code) combinand env)
  (assert (zerop (nclosed combiner)))
  (let ((module (module combiner))
        (frame (make-frame (nregs combiner) (nstack combiner))))
    (setf (reg frame 0) combinand (reg frame 1) env)
    (vm (bytecode module) frame #() (constants module) :ip (xep combiner))))

(defmethod i:combine ((combiner closure) combinand env)
  (let* ((code (code combiner))
         (closed (closed combiner))
         (module (module code))
         (frame (make-frame (nregs code) (nstack code))))
    (setf (reg frame 0) combinand (reg frame 1) env)
    (vm (bytecode module) frame closed (constants module) :ip (xep code))))
